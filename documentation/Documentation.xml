<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<book>
    <bookinfo>
        <title>Blackjack-Implementation with XML-Technologies</title>
        <subtitle>Documentation - XML-Technologies</subtitle>
        <subtitle>Winter term 2020 - Group DocBook</subtitle>
        
        <author>
            <firstname>Patryk</firstname>
            <surname>Brzoza</surname>
        </author>
        <author>
            <firstname>Moritz</firstname>
            <surname>Issig</surname>
        </author>
        <author>
            <firstname>Fami</firstname>
            <surname>Mahmud</surname>
        </author>
    </bookinfo>
    <chapter id="introduction">
        <title>Introduction</title>
        <para>This DocBook documents the development and implementation of a multi-client Blackjack
            game, which is only using XML-Technologies. We present an overview over these
            Technologies and the way we used them. Furthermore, it describes the rules and
            strategies we agreed on for our Blackjack Game, the important phases with possible user
            actions, the interaction between client and server, as well as the design and
            implementation in detail. A complete walkthrough with the installation of the game and
            an example of a game play is shown. In addition, we discuss the way we organized our
            project and reflect on positive and negative aspects. </para>

        <sect1>
            <title>Project Overview</title>
            <para>The Project is part of the practical course XML-Technologies (IN0012, IN2106,
                IN4013) in the winter term 2019/2020. Throughout the lecture Prof. Anne
                Brüggemann-Klein and Phillip Ulrich introduced us to the XML-Technologies such as
                SVG, XHTML, XSLT, XQuery and XPath. The objective of this project is to implement a
                multi-client browser game of Blackjack by making use of XML-Technologies
                exclusively. </para>
            <para>During the first part of the lab we received tasks every week which we were able
                to complete with the newly introduced technology. In this manner we were able to get
                to know and to practice the use of the important technologies step by step. </para>
            <para>The second part, the actual development project, began after the last meeting in
                the second week of January. We had to organize ourselves within the group and decide
                on methodologies on how to implement, design and document the requirements stated in
                the project assignment. The project ends with the completed game, documentation and
                a final presentation. </para>
        </sect1>
        <sect1>
            <title>Blackjack Concept</title>
            <para>We decided to implement a general Blackjack game according the basic rules defined
                by Bicycle [<ulink url="https://bicyclecards.com/how-to-play/blackjack/"/>]. We did
                not implement additional rules like 'splitting pairs' or 'doubling down'. </para>
            <sect2>
                <title>Game Rules</title>
                <para>The target of each player is to reach a combined card value as close to 21 as
                    possible, without going over 21 but beating the dealer. </para>
                <sect3>
                    <title>Players</title>
                    <para>To start a round at least one player has to be in the game, but in one
                        game a maximum of 7 players are allowed. Nevertheless, every player is
                        playing each for himself against the dealer, which is represented by the
                        computer. </para>
                </sect3>
                <sect3>
                    <title>Betting</title>
                    <para>Every player bets an amount of chips, which will be placed in the pool.
                        Obviously it is not possible to bet more chips than the participant has in
                        its wallet. </para>
                </sect3>
                <sect3>
                    <title>Cards</title>
                    <para>We use a six-deck game, which means that six decks with 52-cards are
                        combined to 312-cards. In the dealing phase two cards face up will be
                        distributed to each player after the betting phase. The Dealer takes one
                        card face up and the second card face down. Each card takes its pip value
                        and face cards are 10. Aces can take the value of 11 or 1, this depends on
                        the count. If the count is over 21 the value of ace switches to 1. </para>
                </sect3>
                <sect3>
                    <title>The Play</title>
                    <para>As a player you must decide if you want to get another card ("hit") or if
                        you don't want another card ("stand"). You can repeat this until you reach a
                        count over 21. </para>
                </sect3>
                <sect3>
                    <title>Dealer's Play</title>
                    <para>Once all players stand on their Cards the dealer's second card gets turned
                        up. Now the dealer takes cards until he has a count of 17 or more, at which
                        point the dealer must stand. </para>
                </sect3>
                <sect3>
                    <title>Pay Phase</title>
                    <para>The winner gets determined by comparing the count of the player with the
                        dealer's total card value. A player wins and gets paid double of his bet
                        when the dealer has a lower hand or if the dealer goes bust. The dealer wins
                        if he has a higher hand or the player goes bust. In this case the player
                        loses his bet. A tie is possible if both have the same total value. Then the
                        player gets back his bet.</para>
                </sect3>
            </sect2>
        </sect1>

    </chapter>
    <chapter id="technologies">
        <title>Technologies</title>
        <para>As a both mentioned we were introduced into powerful Tools which make it possible
            write a documentation, to save and encode data of a game state, to generate a GUI using
            the saved data, as well as interact with data. In the following these Tools are
            addressed and briefly introduced.</para>
        <sect1>
            <title>XML</title>
            <para>XML is the basis for this project. It stands for Extensible Markup Language and
                defines a set of rules in which documents get encoded in a platform independent
                format that is readable for humans and computers due to its clear and simple
                structure. The data of game states are encoded in XML and therefore can easily be
                transformed and transferred to the web. </para>
        </sect1>
        <sect1>
            <title>DocBook</title>
            <para>DocBook is a semantic markup language which we use for our documentation. It
                simplifies the creation of documents with a clear logical structure. In addition,
                the data is saved in a neutral format which makes it possible to easily transform it
                to a variety of formats, including HTML, XHTML, PDF, etc. Furthermore, the content
                quality can be improved by automatic validation through a DTD file.</para>
        </sect1>
        <sect1>
            <title>SVG</title>
            <para>SVG (Scalable Vector Graphics) is a language to define vector based 2-dimensional
                graphical objects. SVG images are defined in XML-format. We used it to create all
                our graphical components like cards, chips, buttons, etc. </para>
        </sect1>
        <sect1>
            <title>XSLT</title>
            <para>"XSLT (Extensble Stylsheet Language Transformations) is a language for
                transforming XML documents into other XML documents or other formats such as HTML
                for web pages, plain text or XSL Formatting Objects, which may subsequently be
                converted to other formats, such as PDF, PostScript and PNG. "(Source: <ulink url="https://en.wikipedia.org/wiki/XSLT"/>). In our project it is used to
                dynamically transform our game states encoded in XML into an XHTML document, which
                can be used to graphically display the game state in the browser. Moreover, the
                chips and cards are dynamically transformed using XSLT. The elements of the XML
                documents are selected with a query language called XPath. XPath is a big a part of
                XSLT and widely used to navigate through elements and attributes. </para>
        </sect1>
        <sect1>
            <title>XQuery</title>
            <para>Xquery is a very efficient querying language for XML databases. It enables the
                interaction with the databases. Which makes it possible to delete, insert and
                replace database nodes. Just like in XSLT nodes are addressed using XPath. The game
                actions are implemented using Xquery functions. The functions are initiated by
                HTTP-Request which are mapped by RESTXQ-Annotations (for example:
                "localhost:8984/docbook_blackjack/lobby"). </para>
        </sect1>
        <sect1>
            <title>BaseX</title>
            <para>BaseX is a management system for XML databases and a Xquery processor. BaseX
                represents the server side of our implementation to store the databases. It makes it
                possible to query big XML documents as well as transfer the transformed data to the
                clients using Websockets. </para>
        </sect1>
        <sect1>
            <title>Websocket</title>
            <para>Since a REST-Response can only be send to the client, who sent the REST-Request,
                Websockets are an usefull tool to send updates also to clients, which doesn't sent a
                request. BaseX-STOMP offers these websockets. If a client opens a page he subscribes
                to the websocket. This websocket-connection will not be closed. The server can then
                send massages to all clients, which subscribed to the websocket. Also a client can
                send a message to the server.</para>
        </sect1>
    </chapter>
    <chapter id="requirements">
        <title>Project Requirements</title>
        <sect1>
            <title>Official Requirements</title>
            <para></para>
        <para>The project requirements were initially specified in the project exercise and describe
            the expected functionality of the Blackjack game while at the same time acting as the
            project backlog for our development process. Based on the given aspects, we have
            considered the following points for our final implementation:</para>
        <itemizedlist>
            <listitem>
                <para>The game should follow the blackjack concept as introduced in <link
                        linkend="introduction">Chapter 1</link>.</para>
            </listitem>
            <listitem>
                <para>The project is to be implemented as a web application by purely making use of
                    XML technologies described in the <link linkend="technologies">Chapter
                    2</link>.</para>
            </listitem>
            <listitem>
                <para>The game must be implemented using the multi-client principle, i.e. it should
                    be possible for multiple persons to play one single game within their own client
                    instance.</para>
            </listitem>
            <listitem>
                <para>Apart from the game functionality itself, a Lobby must be implemented such
                    that players are able to register themselves and to create or join games.
                    Players are assigned a randomly generated ID which can be used to restore player
                    accounts from previous sessions.</para>
            </listitem>
            <listitem>
                <para>The Lobby should also include a highscore board keeping track of the highest
                    player scores achieved throughout their finished games.</para>
            </listitem>
            <listitem>
                <para>The system architecture must follow the Model-View-Controller (MVC) pattern.
                    Each method should be included in its particular module, which is responsible
                    for its area in the MVC model.</para>
            </listitem>
            <listitem>
                <para>A high degree of parametrization and customizability should be given in order
                    to guarantee a high reusability of system fragments. This encourages the general
                    software engineering rule of low coupling and high cohesion between
                    modules.</para>
            </listitem>
            <listitem>
                <para>The design process is to be modelled and documented adequately, thus
                    encouraging a model driven development process. For instance, the usage of
                    low-fidelity prototypes such as sketches allows to describe the functionality of
                    the user interface. Class diagrams should be used to model data and method
                    relations, activity and state diagrams should model the system behavior.
                    Additionally, a description of all REST requests and responses between the
                    client and the server should be created.</para>
            </listitem>
            <listitem>
                <para>Finally, the previous design models and decisions are to be included in this
                    documentation, which should give an overview of the whole project.</para>
            </listitem>
        </itemizedlist>
        </sect1>
        <sect1>
            <title>Additional Features</title>
            <para>In addition to the above stated required functionalities we decided to implement
                extra features. <itemizedlist>
                    <listitem>
                        <para>Possibility to play multiple games administered by one server </para>
                    </listitem>
                    <listitem>
                        <para>Deployment to a web server, which makes it possible to play the game
                            without further requirements, installations and from distributed
                            positions locations</para>
                    </listitem>
                </itemizedlist></para>
        </sect1>
    </chapter>
    <chapter id="design">
        <title>Design and Implementation</title>
        <para>The Implementation is seperated in the different languages as explained above. Here we
            go more into detail regarding the different components of our architecture. </para>
        <sect1>
            <title>Templates</title>
            <para>The XSLT templates are used to dynamically generate a html output depending on the
                current game state. </para>
            <sect2>
                <title>Lobby Template</title>
                <para>Once a user calls the link to the Lobby ("/docbook_blackjack/lobby") the
                    parameters "isLoggedIn", "playerName", "playerId", "playerHighscore" are passed
                    to the template. It uses these parameters and the current lobby database to
                    generate the appropriate SVGs and HTML page. There are two different options how
                    a Lobby is presented. Either the "isLoggedIn" parameter is set to 0, which means
                    that no account is loaded yet. </para>
                <para>This renders to a Lobby looking like this:</para>
                <figure>
                    <title>Lobby Interface - not logged in</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="img/Lobby/LobbyImplementation2.png" width="700px"/>
                        </imageobject>
                    </mediaobject>
                </figure>
                <para>The graphical user interface changes when the user creates an account or
                    restores his account by typing in his name and id. </para>
                <figure>
                    <title>Lobby Interface - logged in</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="img/Lobby/LobbyImplementation.png" width="700px"/>
                        </imageobject>
                    </mediaobject>
                </figure>
                <para>At the beginning of our project we started with creating basic prototypes. As
                    you can see in the following sketch, the implementation derived strongly out of
                    the first mockup.</para>
                <figure>
                    <title>Lobby Prototype</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="img/Lobby/LobbyPrototype.png" width="700px"/>
                        </imageobject>
                    </mediaobject>
                </figure>
            </sect2>
            <sect2>
                <title>Game Template</title>
                <para>The Game Template is called to display the game state in the view of each
                    player who are differentiated using websockets. Different views, in which the
                    buttons vary, are presented depending on the phase and which actions are
                    currently possible. All phases are explained in detail in <link linkend="phases"
                        >Section 4.4</link>. Every time a user performs an action, such as to bet or
                    to take another card, the game state changes. Therefore the view has to be
                    refreshed by performing the game template and sending it to the related users. </para>
                <para>The position of a players on the screen is dynamically calcuated using a
                    function, that takes into consideration how many players are part of the game.
                    For each player their respective Name and ID is shown in the top left corner.
                    This can only be seen by the players themselves. On the other side name, wallet,
                    bet and cards are always viewable for all players. </para>
                <para/>
                <figure>
                    <title>Table Interface</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="img/Table/TableImplementation.png" width="700px"/>
                        </imageobject>
                    </mediaobject>
                </figure>
                
                <para>Similar to the Lobby our implementation remained almost equivalent to the
                    first mockup. </para>
                <figure>
                    <title>Table Prototype</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="img/Table/TablePrototype.png" width="700px"/>
                        </imageobject>
                    </mediaobject>
                </figure>
            </sect2>
            <sect2>
                <title>Card Template</title>
                <para>Cards are generated once they are needed. This happens through a
                    &lt;xsl:call-template> that is called in the game template, when ever someone
                    draws a card. The value and type is passed as a parameter. The first step is to
                    check if the card is hidden, if so the templates just draws a pattern and
                    returns. Otherwise the value is written in the top left and bottom right corner.
                    Icons are loaded depending on the card type and placed in a number of positions
                    according to the value. The positions and rotation of the icon are saved in a
                    different xml file. We used these schemes to create the icons in SVG.</para>
                <figure>
                    <title>Icons</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="img/Icons.png" width="500px"/>
                        </imageobject>
                    </mediaobject>
                </figure>
            </sect2>
            <sect2>
                <title>Chip Template</title>
                <para>Just as the creation of cards, chips are generated by calling the chip
                    template and passing the value as a parameter. Possible chip values are 10, 50,
                    100, 250, 500 and 1000. Of course they determine the value as well as the
                    color.</para>
                <para>In the template we take advantage of &lt;symbol> and &lt;use> elements to
                    create a chip in three steps. First the outercircle is filled with the chip
                    color and thick white lines. Above the first cirle and lines another smaller
                    circle is drawn in the color of the chip. The final step is to add the dotted
                    circle wherein the value is written. </para>
                <para><inlinegraphic fileref="img/Chip1.png" width="250px"/>
                    <inlinegraphic fileref="img/Chip2.png" width="250px"/>
                    <inlinegraphic fileref="img/Chip3.png" width="250px"/>
                </para>
            </sect2>
        </sect1>
        <sect1>
            <title>Modules</title>
            <para/>
            <figure>
                <title>Class-Diagram: Modules</title>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="diagrams/Klassendiagramm.png" width="700px"/>
                    </imageobject>
                </mediaobject>
            </figure>
        </sect1>
        <sect1 id="phases">
            <title>Phases</title>
            <para/>
            <para>The Lobby as well as the Game have severale states. An user in the Lobby can be
                either in the "not logged in"-state or in the "logged in"-state. To switch from the
                "not logged in"-state to the "logged in"-state the user has to create a new Account
                (via the createAccount()-function) or, if s*he knows the Id, restore an existing
                Account (via the restoreAccount()-function).</para>
            <para>There are two ways from the Lobby to a Game. First by creating a new game (either
                a singleplayer or multiplayer game) with the newGame()-function or secondly by
                joining an existing multplayer game with the joinGame()-function. In each phase of
                the game a player can leave this game and return to the Lobby (with the
                leave()-function). </para>
            <figure>
                <title>State-Diagram: Game-Phases</title>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="diagrams/Zustandsdiagramm%20Game.png"/>
                    </imageobject>
                </mediaobject>
            </figure>
            <para>A game has four phases:<orderedlist>
                    <listitem>
                        <para>The starting phase is the bet-phase. If an player enters this phase he
                            will subscribe to the websocket of this game. Also the deck will be
                            reseted All players can bet chips for the netxt round at the same time.
                            Also they can reset their bets to correct mistakes. If all players have
                            confirmed their bets the game switches to the deal-phase.</para>
                    </listitem>
                    <listitem>
                        <para>The deal-phase is completely processed be the backend-system. Firstly
                            each player and the dealer gets one card from the deck. Since this is
                            the frist card for the dealer his card will be hidden. After a database
                            update, which is necessary because the dealer got a first card, each
                            player and also the dealer gets a second card. Now the dealer gets a
                            revealed card. In the next step the first player is set to the player,
                            which is on turn. And then the phase is set to "play". If a leaving
                            player triggered this phase he will be redirected to the Lobby. If not
                            an update of the game-page will be send via the websocket
                            connection.</para>
                    </listitem>
                    <listitem>
                        <para>In the play-phase each player does his turn one after another. A
                            player can hit or stand during his turn. After the last player finished
                            his turn the dealerTurn starts. During the dealerTurn the delaer draw a
                            card if his hand value is lower than 17, updates the databank and
                            restarts the dealerTurn with the additional card. If the hand value is
                            17 or higher he stands and the phase changes to "pay". As in the
                            deal-Phase the dealerTurn can also be triggered by a leaving player. If
                            so this player will be redireted also to the Lobby. If not an update of
                            the game-page will be send via the websocket connection.</para>
                    </listitem>
                    <listitem>
                        <para>The last phase is the pay-phase. At the start of this phase the result
                            of the game is presented on the table. If any player decides to continue
                            all players will be pay, if they win, then their hands and their pools
                            will be cleared. The dealer also clears his hand. Then the game switches
                            to the bet-phase and an update of the game-page will be send via the
                            websocket connection.</para>
                    </listitem>
                </orderedlist></para>
            <figure>
                <title>Activity-Diagram: Deal-Phase</title>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="diagrams/Aktivitaetsdiagramm%20Deal-Phase.png"/>
                    </imageobject>
                </mediaobject>
            </figure>
            <para/>
            <figure>
                <title>Activity-Diagram: Dealer-Turn</title>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="diagrams/Aktivitaetsdiagramm%20DealerTurn.png"/>
                    </imageobject>
                </mediaobject>
            </figure>
        </sect1>
    </chapter>
    <chapter id="architecture">
        <title>Architecture</title>
        <para>This chapter discribes the connections between the different hardware-components,
            which are basing on a model-view-controller architectur. The second section present the
            data-models of the lobby, containing the scores and the games, and the card-values,
            which will be used to generate the card-svgs.</para>
        <sect1>
            <title>MVC Architecture</title>
            <para>The program is seperated in the components: Model, View and Controller:<itemizedlist>
                    <listitem>
                        <para><emphasis role="bold">The Model</emphasis>-component contains the
                            stored data as XML in a database. This database process the updating
                            constrains, which will be sent by the Controller-component. Also the
                            Model-component send the requested data as XML-elements to the
                            Controller.</para>
                    </listitem>
                    <listitem>
                        <para><emphasis role="bold">The View</emphasis>-component is the graphical
                            user interface for the user-client. This GUI will be sent from the
                            Controller in a HTML and SVG format, either as an REST-response or via
                            the websocket-connection. Also the Views can send REST-Requests to the
                            Controller to perform changes on the Model and to get the Model.</para>
                    </listitem>
                    <listitem>
                        <para><emphasis role="bold">The Controller</emphasis>-component is placed on
                            the Server and processes the incoming REST-Requests. Therefore it uses
                            XQuery as a functional programming-language. Additionally it uses XSLT
                            to generate the HTML and SVG out of the model-data and send them to the
                            View.</para>
                    </listitem>
                </itemizedlist></para>
            <figure>
                <title>Modell: Model-View-Controller</title>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="diagrams/MVC-Modell.PNG"/>
                    </imageobject>
                </mediaobject>
            </figure>
        </sect1>
        <sect1>
            <title>Data Model</title>
            <para>The datas are saves in XML on the BaseX database-Server.</para>
            <sect2>
                <title>Lobby-Model</title>
                <para>The data-model of the lobby start with the lobby itselft as the root-element.
                    Inside the lobby are a scores-element, which contains all scores, and several
                    games. These games always contain one deck with up to 312 cards, one dealer and
                    a element players, where all players are stored. The players also have one
                    wallet and one pool, where the bet chips will be saved. Aditionally all players
                    and also the dealer elements contain one hand, this hand then can hav up to 22
                    cards (21 aces and one additional card).</para>
                <figure>
                    <title>Data-Model: Lobby</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="diagrams/Lobby-Datenmodell.png" width="700px"/>
                        </imageobject>
                    </mediaobject>
                </figure>
            </sect2>
            <sect2>
                <title>Card-Value-Model</title>
                <para>To generate the number-cards dynamicly, we use a xslt-file, which creates the
                    svg of a card based on the values-xml. For each card-value (ace - 10), where is
                    a value-element with the character of that value (A - 10). Inside these
                    value-elements are a list of all points, where the card has a symbol (1 point
                    for ace, …, 10 points for 10) and also if this symbl will be rotated.</para>
                <figure>
                    <title>Data-Model: Card-Value</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="diagrams/Values-Datenmodell.png"/>
                        </imageobject>
                    </mediaobject>
                </figure>
            </sect2>
        </sect1>
    </chapter>
    <chapter id="installation">
        <title>Game Installation</title>
        <para>Additional to the project requirements we deployed our project to a web server, hence
            there are two ways of playing our Blackjack game: <orderedlist>
                <listitem>
                    <para>Online on the web server using this URL: <ulink url="http://blackjack.brzoza.me"/>
                    </para>
                </listitem>
                <listitem>
                    <para>Locally using a BaseX Server on your own Computer</para>
                </listitem>
            </orderedlist></para>
        <para>We recommend the usage of Google Chrome as Browser. Our game is compatible with Google
            Chrome and Firefox on Windows and MacOs, but it is optimized for Google Chrome only.
            (Please don't use Internet Explorer or Safari). </para>
        <sect1>
            <title>Requirements</title>
            <orderedlist>
                <listitem>
                    <para>For the first option the only requirement is an IPv4 connection. The
                        server can not be addressed through IPv6. </para>
                </listitem>
                <listitem>
                    <para>The second option requieres a running BaseX STOMP HTTP server and running
                        BaseX database Server. </para>
                </listitem>
            </orderedlist>
        </sect1>
        <sect1>
            <title>Installation</title>
            <orderedlist>
                <listitem>
                    <para>No installations have to be made to play the game on the web server.
                    </para>
                </listitem>
                <listitem>
                    <para>To install the BaseX STOMP HTTP sever a few steps have to be made <itemizedlist>
                            <listitem>
                                <para>Download the comlplete BaseX program (BaseX931.zip, status
                                    march 2020) from their website <ulink url="http://basex.org/download/"/>. </para>
                            </listitem>
                            <listitem>
                                <para>Download and build the BaseX STOMP packet from the stomp
                                    branch in the git repository (<ulink url="https://github.com/BaseXdb/basex/tree/stomp"/>).</para>
                            </listitem>
                            <listitem>
                                <para>Copy the webapp/docbook_blackjack folder into the webapp
                                    folder of BaseX.</para>
                            </listitem>
                            <listitem>
                                <para>Copy the static/docbook_blackjack folder into the
                                    webapp/static folder of BaseX.</para>
                            </listitem>
                            <listitem>
                                <para>Now you can start the BaseX HTTP server.</para>
                            </listitem>
                            <listitem>
                                <para>The game can be played by calling this link: <ulink url="http://localhost:8984/docbook_blackjack/setup"/>.</para>
                            </listitem>
                        </itemizedlist></para>
                    <para>The databases are created upon first calling the setup link. Once all
                        databases are created, the setup link will directly redirect to the Lobby.
                        To delete the databases, you have to access them directly on the BaseX
                        database administration interface using this link: <ulink
                            url="http://localhost:8984/dba"/></para>
                </listitem>
            </orderedlist>
        </sect1>
    </chapter>
    <chapter id="demo">
        <title>Game Demo</title>
        <para>In this chapter we will present a short demo of the gameplay with screenshots in
            different user situations and from different points of view.</para>
        <para>On the left you can see the lobby which is shown, before you are logged in and on the right once you created or restored a account.</para> 
        <para><inlinegraphic fileref="img/GameDemo.png" width="400px"/>
             <inlinegraphic fileref="img/GameDemo2.png" width="400px"/></para>
        <para>Mandela created a multiplayer game, that Obama can join by clicking the game button in
            the scrollable games list. On the right side tha game is in the bet phase and Obama has
            already confirmed his bet, what can be seen by the checkmark next to his name. Obama has
            no buttons to press and is now waiting for Mandela to confirm his bet. </para>
        <para><inlinegraphic fileref="img/GameDemo3.png" width="400px"/>
            <inlinegraphic fileref="img/GameDemo4.png" width="400px"/>
        </para>
        <para>In these two pictures the view of Mandela during the play phase is shown. After two
            cards are dealt to both players, Mandel can press the button hit or stand on the left
            picture. Mandel is satisfied with his hand and presses stand. That leads to the right
            situation in which Mandela is waiting for Obama to hit or stand. As you can see the box
            of the player who is on turn is colored gold.</para>
        <para><inlinegraphic fileref="img/GameDemo5.png" width="400px"/>
            <inlinegraphic fileref="img/GameDemo6.png" width="400px"/>
        </para>
        <para>After players stand or go bust we are in the pay phase where the final hands of
            dealer and players are shown. Through the button Continue the players have the
            possibility to start a new round. The Exit button can be used to get back to the lobby. </para>
        <para><inlinegraphic fileref="img/GameDemo7.png" width="400px"/>
        </para>
    </chapter>
    <chapter>
        <title>Team Organisation</title>
        <para>Our team was formed at the beginning of the practical course and consists of three
            team members, namely Patryk Brzoza, Moritz Issig and Fami Mahmud. To allow for
            asynchronous communication with each other, we created a Telegram group, where we could
            discuss our project apart from our weekly meetings.</para>
        <sect1>
            <title>Development Environment</title>
            <para>In order to manage and modify our codebase between all team members, we created a
                Git repository hosted on the LRZ GitLab. This allowed us to fully make use of the
                powerful functionality given by Git. We used separate branches to implement new
                features, which we then merged to the master branch upon implementation.
                Additionally, it is possible to keep track of and resolve known issues by using the
                included issue tracker. The web interface allows to inspect files on-the-go without
                having direct access to the Git repository. To resolve merge conflicts, we used the
                Git CLI and SourceTree. For the development process itself we used IntelliJ IDEA, as
                it allows for extensibility through numerous plug-ins, e.g. to allow syntax
                highlighting of XQuery files or in order to transform documents using XSLT.</para>
            </sect1>
            <sect1>
                <title>SCRUM</title>
                <para>Due to the constant addition of new requirements and the rather small size of
                our team, we decided that an agile project management structure would fit our
                development process best and chose SCRUM to be a suitable framework to apply it. The
                overall requirements defined at the beginning of the project are defined in the
                project backlog which acts as a guideline for the whole project life cycle. We have
                defined these requirements in <link linkend="requirements">Chapter 3</link>. </para>
                <figure>
                    <title>The SCRUM development process [<ulink
                        url="https://commons.wikimedia.org/w/index.php?curid=3526338"
                    />]</title>
                <mediaobject>
                    <imageobject><imagedata fileref="img/Scrum.png" width="700px"/></imageobject>
                </mediaobject>
                </figure>
                <para>The actual development process is subdivided into multiple iterations of a
                fixed length defined as <emphasis>sprints</emphasis>, which we chose to match the
                exercise sheet working time of one week. Each sprint consists of another sprint
                backlog, which includes the work to be done within one sprint and mostly matched the
                content of the given exercise sheet. We defined this during the weekly SCRUM
                meeting, which mostly took place before or after the weekly practical course
                lecture. Each team member then chose which sprint backlog item should be assigned to
                him and then proceeded to implement it during the sprint. One advantage of the SCRUM
                process is that each sprint terminates with a potenially deliverable product
                increment, which made the development process much easier for us as we could improve
                the functionality of our existing product each week.</para>
            </sect1>
            <sect1>
                <title>Continuous Deployment</title>
                <para>In addition to our code repository managed on GitLab, we implemented a script
                    which automatically deploys the most recent commit version onto our web server
                    which is running an instance of our project on a BaseX HTTP and database server.
                    This allows us to perform tests which are not dependent on the operating system
                    or the server instance that is running at the client of each operating
                    system.</para>
            </sect1>
    </chapter>
    <chapter id="conclusion">
        <title>Conclusion</title>
        <para>Summarizing the previous chapters, we implemented a fully functional instance of the
            game Blackjack by solely applying XML technologies, which includes SVG, XSLT, XQuery and
            BaseX. Our development process was based on official and personal requirements which
            were set at the beginning of the project. All parts of the graphical user interface were
            derived from low-fidelity prototype sketches, which were then incrementally given more
            functionality. To support a model-driven development process, we based our architecture
            on the Model-View-Controller (MVC) pattern and implemented all game modules according to
            it. The main game process was subdivided into four phases, each of which defined a
            certain step of the Blackjack game according to its ruleset. Additionally, we defined
            data models for each part of the database in order to allow for complex yet efficient
            data structures. We applied an agile development process based on SCRUM in order to
            handle with ongoing requirement change and made use of contionuous deployment for
            extensive testing between all team members.</para>
        <sect1>
            <title>Challenges</title>
            <para>There were numerous challenges that we needed to dealt with throughout the
                development phase. At first, most of us were familiar with XML as a markup language
                itself, however most of the introduced technologies were new to us. Due to the good
                organization structure of the practical course, we were able to progressively get
                known to each technology by applying it on a real use case. For example, one
                challenge which was thoroughly analyzed by us was how the card generation could be
                implemented in SVG without introducing redundancy. With the introduction of XSLT
                this task was greatly faciliated, as we could use pre-defined functions and loops
                for a efficient card generation. Another problem we hat to cope with were the
                differences between our systems during the development process. It turned out that
                many components behaved differently depending on where they were deployed. For
                example, UI elements were often rendered differently on macOS and Windows, which led
                to numerous adaptations in the CSS stylesheets. On the other hand, function
                parameters were also often treated differently depending on the XSLT processor, as
                the isLoggedIn parameter inside the lobby template was not recognized at all for one
                team member. We were able to resolve this problem by implementing continuous
                deployment, where we pushed the most recent version of our game onto a web server
                which could be then accessed independently by each member. One complex challenge was
                theapplication of Websockets, as the technology is not yet fully supported by the
                official release of BaseX and the technology was fairly new to us. However, upon
                gaining more knowledge and supporting each other we were able to resolve this
                problem together. Finally, there were some problems with the automatic generation of
                our XQuery documentation files by xqDoc. Due to a bug in Oxygen, no output could be
                created even though the files themselves were valid. Thanks to the kind help of
                Prof. Brüggemann-Klein and Philipp Ulrich we eventually able to successfully create
                the documentation files.</para>
        </sect1>
        <sect1>
            <title>Reflection</title>
            <para>During the practical course we have learned incredibly lot about the wide range of
                XML technologies and the possibilities that can be achieved through applying them,
                which if why we fully recommend it, especially as there are not many courses that
                introduce informatics students into them inside the obligatory study curriculum. We
                also earned a lot of valuable knowledge about teamwork and software engineering
                within software projects, as we got along with each other very well and supported
                each other during the implementation phase.</para>
        </sect1>

    </chapter>
</book>
